---
title: "Coverage regression"
output: html_document
date: "2022-12-02"
---

```{r}
library(haven)
library(dplyr)
library(ggplot2)
library(readr)
library(measurements)
library(geosphere)

#running this should automatically configure the filepath
path <- paste0(getwd(), '/data/raw/')
setwd(path)
```

```{r}
# load all relevant datasets
commtowers <- read_dta('commtowers.dta')
coverage <- read_dta('coverage.dta')
```

```{r}
# Find relevant columns in commtowers
is_uhf <- as.integer(commtowers$channel > 13) # 0 is VHF, 1 is UHF
is_uhf

# We want Visual Power to be in increments of 100 kW.
# I think power_vis column is in kW, so divide by 100.
kw_100 <- commtowers$power_vis / 100

# We want height above ground to be measured in increments of 100 feet
# hgtground column is in feet, so divide by 100
hgt_100 <- commtowers$hgtground / 100

tower_df_unclean <- data.frame(is_uhf, kw_100, hgt_100, station=commtowers$station)
tower_df <- na.omit(tower_df_unclean)

#remove satellite stations from consideration
coverage <- coverage[coverage$satellite == 0,]

# Calculate distance from county centroid to channel's tower
covrate_linearized <- coverage$covrate
covrate_linearized[covrate_linearized=="5-24%"] <- 20
covrate_linearized[covrate_linearized=="25-50%"] <- 40
covrate_linearized[covrate_linearized=="over 50%"] <- 90
covrate_linearized[covrate_linearized=="."] <- NA

dists <- sapply(1:nrow(coverage), function(i) {
  # Get <station, county> pair
  stn <- coverage$station[i]
  county_lat <- coverage$lathh[i]
  county_long <- coverage$longhh[i]
  if (stn %in% commtowers$station) {
    # compute distance from that county's population centroid to the station's tower
    tower_info <- commtowers[commtowers$station==stn,]
    dist <- distm(c(county_long, county_lat), 
          c(tower_info$longtower, tower_info$lattower), fun = distHaversine)
    
    # Convert meters to miles
    dist_mi <- conv_unit(dist, "m", "mile")
    return(dist_mi)
  } 
  return(NA)
})

dists[dists>=200] <- NA
# Each row is a <county, station> pair, with its distance to the broadcasting tower
cov_df <- na.omit(data.frame(station=coverage$station, dists_10 = dists/10, 
                             covrate_linearized,
                             state=coverage$state_hh, county=coverage$county_hh, 
                             totalhh = coverage$totalhh))
# Join with info on the tower
cov_df <- inner_join(x=cov_df, y=tower_df, by = 'station')

#sum(is.na(cov_df)) # no na's

coverage.lm <- lm(covrate_linearized ~ dists_10 + is_uhf + kw_100 + hgt_100 
                  + dists_10*is_uhf, data=cov_df, weights=totalhh)

coef(coverage.lm)
```

Something different and fun I want to try: what if we did a logistic regression,
and disaggregated the data so that each observation is a TV household in a county-station pairing,
and the response variable is now whether or not that TV household in that county can receive the station.
We have coverage rates for all TV households in each county-station pairing already, and the number of TV households in the county, so we can just multiply to get the number of TV households that get the station, and disaggregate so that
a proportion (the coverage rate) of TV households get '1' as the response and everyone else gets '0'.
Who gets '1' and who gets '0' doesn't matter, since there are no other household-level variables to worry
about (everyone in a county-station pairing has the same covariates).

```{r}
# extra: logistic regression model
households <- cov_df$totalhh
covrates <- as.integer(cov_df$covrate_linearized) / 100
viewers <- round(households*covrates)
not_viewers <- households - viewers
for (i in 1:nrow(cov_df)) {
  ctystation_viewers <- rep(1, viewers[i])
  ctystation_notviewers <- rep(0, not_viewers[i])
  ctystation_outcome <- c(ctystation_viewers, ctystation_notviewers)
  
  
}


```

```{r}
# maybe we can try this later, don't worry about this now
big_df <- cov_df[rep(row.names(cov_df), cov_df$totalhh),]

cov_df
```


